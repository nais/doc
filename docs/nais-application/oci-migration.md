# How to migrate from GitHub Container Registry (GHCR) to Google Artifact Registry (GAR)

## Why migrate?

GHCR serves as a OCI registry hosted by GitHub, but it has certain limitations, such as imposing strict rate
limits on the number of requests. We've encountered challenges with these rate limits, particularly when upgrading a
cluster or restoring from a backup. In such instances, we've had to patiently wait for the rate limits to reset before
deploying / restoring our applications.

On the other hand, GAR is a OCI registry hosted by Google, and we find it to be a more favorable solution for our
needs. Additionally, as we transition to the cloud, the seamless integration with the Google Cloud Platform further
enhances its appeal as a beneficial option for our operations.

### Migrate

You can switch from GHCR to GAR by following these steps
to update your current workflow. Let's simplify this by taking an
example of a workflow using GHCR and show you exactly how to change it
to GAR.

The [docker-build-action](https://github.com/nais/docker-build-push) is employed for building and publishing the
Docker image to GAR.
Subsequently, the [deploy-action](https://github.com/nais/deploy/tree/master/actions/deploy) facilitates the
deployment of the application to a cluster.

```yaml
name: Build, push, and deploy

on: [ push ]

env:
  IMAGE: ghcr.io/navikt/my-team/my-app:${{ github.sha }}

jobs:
  build:
    runs-on: ubuntu-latest
    permissions: write-all
    steps:
      - uses: actions/checkout@v4
      - name: Build and test my-app
        run: some build steps..
      - name: Build and publish Docker image
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo ${GITHUB_TOKEN} | docker login docker.pkg.github.com -u ${GITHUB_REPOSITORY} --password-stdin
          echo ${GITHUB_TOKEN} | docker login ghcr.io -u ${{github.actor}} --password-stdin
          docker build -t ${IMAGE} .
          docker push ${IMAGE}

  deploy:
    name: Deploy to NAIS
    runs-on: ubuntu-latest
    needs: [ build ]
    steps:
      - uses: actions/checkout@v4
      - uses: nais/deploy/actions/deploy@v1
        env:
          APIKEY: ${{ secrets.NAIS_DEPLOY_APIKEY }}
          CLUSTER: target-cluster
          RESOURCE: nais.yaml
          VAR: image=${{ env.IMAGE }}
```

Initially, eliminate the environment variable: `IMAGE: ghcr.io/navikt/my-team/my-app:${{ github.sha }}`, as
the `nais/docker-build-action`, automatically generates this value and outputs it as the `image` variable.

```yaml
europe-north1-docker.pkg.dev/nais-management-233d/my-team/my-app
```

The resulting image reference is composed of the following:

* Registry: `europe-north1-docker.pkg.dev`
* Google Cloud Project: `nais-management-233d`
* Team: `my-team`
* Application: `my-app`

The tag is automatically generated by the `nais/docker-build-action` or can be specified as input to
the [action](https://github.com/nais/docker-build-push).

If you wish to refer to the image later, please consult the guide
on [Image registry](https://doc.nais.io/guides/application/#step-6-push-your-image-to-our-image-registry).

* Substitute the preceding code block and replace it with the following:

```yaml
  - name: Build and publish Docker image
    env:
      GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
    run: |
      echo ${GITHUB_TOKEN} | docker login docker.pkg.github.com -u ${GITHUB_REPOSITORY} --password-stdin
      echo ${GITHUB_TOKEN} | docker login ghcr.io -u ${{github.actor}} --password-stdin
      docker build -t ${IMAGE} .
      docker push ${IMAGE}
```

```yaml
  - name: Push docker image to GAR and sign image
    uses: nais/docker-build-push@v0
    id: docker-build-push
    with:
      team: my-team
      identity_provider: ${{ secrets.NAIS_WORKLOAD_IDENTITY_PROVIDER }} # Provided as Organization Secret
      project_id: ${{ vars.NAIS_MANAGEMENT_PROJECT_ID }} # Provided as Organization Variable
```

* In the "deploy" job, substitute the given image reference, with the output of the previous step. The output of the
  previous step is the `image` variable, given the example over it can be referenced as
  follows; `${{ steps.docker-build-push.outputs.image }}`.

```yaml
    env:
      APIKEY: ${{ secrets.NAIS_DEPLOY_APIKEY }}
      CLUSTER: target-cluster # Replace
      RESOURCE: nais.yaml
      VAR: image=${{ env.IMAGE }}
```

```yaml
    env:
      APIKEY: ${{ secrets.NAIS_DEPLOY_APIKEY }}
      CLUSTER: target-cluster # Replace 
      RESOURCE: nais.yaml
      VAR: image=${{ needs.build.outputs.image }}
```

* If you haven't already, add scoped permissions to the workflow. Afterward, modify the following:

```yaml
  permissions: write-all
```

```yaml
  permissions:
    contents: read
    id-token: write
```

The reason why you only should set explicit permissions for a workflow `job`, is because it
brings us into a more 'fine-grained' access model, and makes us a bit less vulnerable to attacks through things like
malicious actions and NPM packages or other elements that can execute code in the workflows.

The `nais/docker-build-push` action requires the `id-token:write` permission to be able to
authenticate with the Google Cloud Platform. The `contents:read` permission is required to be able to clone and build.

For more information about permissions, please refer
to [The GitHub Blog Post](https://github.blog/changelog/2021-04-20-github-actions-control-permissions-for-github_token/)

* The finalized workflow should resemble the following:

```yaml
name: Build, push, and deploy

on: [ push ]

jobs:
  build:
    name: Build and push Docker container
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write
    outputs:
      image: ${{ steps.docker-build-push.outputs.image }}
    steps:
      - uses: actions/checkout@v4
      - name: Build and test my-app
        run: some build steps..
      - uses: actions/checkout@v4
      - name: Push docker image to GAR
        uses: nais/docker-build-push@v0
        id: docker-build-push
        with:
          team: myteam # Replace
          identity_provider: ${{ secrets.NAIS_WORKLOAD_IDENTITY_PROVIDER }} # Provided as Organization Secret
          project_id: ${{ vars.NAIS_MANAGEMENT_PROJECT_ID }} # Provided as Organization Variable

  deploy:
    name: Deploy to NAIS
    needs: build
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: nais/deploy/actions/deploy@v1
        env:
          APIKEY: ${{ secrets.NAIS_DEPLOY_APIKEY }}
          CLUSTER: target-cluster # Replace
          RESOURCE: nais.yaml
          VAR: image=${{ needs.build.outputs.image }}
```

The id `docker-build-push` is the id of the previous job step,
there is where your new image will be outputted. In this example we divided our workflow into two jobs, `build`
and `deploy`. The `deploy` job depends on the `build` job, and will not run unless the `build` job is successful.
The `build` job outputs the image reference as `image`, and the `deploy` job can reference this output
as `needs.build.outputs.image`.

## Related documentation

To get more details about deploying to NAIS, please
refer: [Deploy an application](https://doc.nais.io/guides/application/#deploying-an-application)
and [Deploy with GitHub Actions](https://doc.nais.io/deployment/?h=deploy+to#nais-deploy)
